% CREATED BY DAVID FRISK, 2016
\chapter{Theory} \label{chapter:theory}
Our system could be seen as an extension to \emph{$\lambda$-calculus} with dependent types and definitions. In order for the reader to understand better the idea behind the choice of the syntax and semantics of our language, we need first to address some subtleties that differentiate our system from \emph{$\lambda$-calculus} and that back our choice for dealing with the problems about names of the constants.

\section{Subtleties of Dependent Type Theory} \label{theory:subtleties}
We present the subtleties by giving examples as the follows: 

\begin{example}\label{theory:exa1}
  Suppose we have
  \[ a : A, \;\;\; P : A \to U, \;\;\; f : P \, a \to P \, a \]
  where a declaration of the form $x : A$ declares a constant $x$ to be of type $A$; $U$ is the type of small types. Then the term
  \[ \lambda (x : A) (y : P \, x) \; . \; f \, y \]
  is not well typed because the type of $y$, i.e., ($P \, x$), is not necessarily ($P \, a$).

  However, if we modify this term to
  \[ \lambda (x : A = a) (y : P \, x) \; . \; f \, y \]
  where a definition of the form $x : A = B$ declares a constant $x$ to be of type $A$ and defined as term $B$, then it becomes type checked since now the type of $y$ is exactly ($P \, a$).

  We see from this example that the definition of the bound variable ($x$) has an impact on the type safety of the whole expression, meaning that definitions in dependent type theory cannot be reduced to \emph{$\lambda$-calculus}.
\end{example}

\begin{example}\label{theory:exa2}
  Consider the formula
  \[ \lambda (x : \texttt{Nat}) (y : \texttt{Nat} = x) (x : \texttt{Bool}).M\]
  In this formula, the first declaration of $x$ is shadowed by the second one. If we do not treat the shadowing of name $x$ carefully and substitute $x$ for $y$ later when we do computations on $M$, then taking the type of $x$ to be $Bool$ will make $M$ ill-typed.

  This example shows that improper treat of name shadowing leads to mistakes in a dependently typed language.
\end{example}

\begin{example}\label{theory:exa3}
  Suppose we have
  \begin{align*}
    x &: A \\
    y &: A \\
    b &: A \to A \to A \\
    u &: (A \to A \to A) \to (A \to A \to A) \\
    a &: (A \to A) \to (A \to A) \\
    z &: A \to A \to A
  \end{align*}
  Then the term below is well typed.
  \begin{equation} \label{eq-cap-var:1}
    (\lambda u \; . \; u \; (u \; b)) (\lambda z \; y \; x \; . \; a \; (z \; x) \; y)
  \end{equation}
  If we do the reduction on (\ref{eq-cap-var:1}) naively, we get
  \begin{align}
    (\lambda u \; . \; u \; (u \; b)) (\lambda z \; y \; x \; . \; a \; (z \; x) \; y) & \implies \nonumber \\
    (\lambda z \; y \; x \; . \; a \; (z \; x) \; y) ((\lambda z \; y \; x \; . \; a \; (z \; x) \; y) \; b) & \implies \nonumber \\
    (\lambda z \; y \; x \; . \; a \; (z \; x) \; y) (\lambda y \; x \; . \; a \; (b \; x) \; y) & \implies \nonumber \\
    \lambda y \; x \; . \; a \; ((\lambda y \; x \; . \; a \; (b \; x) \; y)\; x) \; y \label{eq-cap-var:2}
  \end{align}
  At this point, we have a capture of variables problem.

  (\ref{eq-cap-var:2}) should be the same as
  \[ \lambda y \; x \; . \; a \; ((\lambda y \; x' \; . \; a \; (b \; x') \; y)\; x) \; y \]
  which reduces to
  \[ \lambda y \; x \; . \; a \; (\lambda x' \; . \; a \; (b \; x') \; x) \; y \]
  But if we do a naive reduction in (\ref{eq-cap-var:2}) without renaming, we get 
  \[ \lambda y \; x \; . \; a \; (\lambda x \; . \; a \; (b \; x) \; x) \; y \]
  which is not correct.

  This example shows another aspect of subtlety when dealing with names of variables in a dependent type theory: the capture of variables.
\end{example}

\section{Principles of Definition Implementation} \label{sec:theory:definition}
The examples listed above provide us with insights into the common pitfalls one should avoid when implementing definitions in dependent type theory. From there, we derived the following principles that guide us through the pitfalls in our own implementation:

\begin{principle} \label{theory:p1}
  For definitions of the form $x : A = B$, treat the type $A$ and the definition $B$ separately.
\end{principle}

\begin{principle} \label{p2}
  Forbid the shadowing of variable names.
\end{principle}

\begin{principle} \label{p3}
  Rename variable whenever necessary. 
\end{principle}

Principle \ref{theory:p1} relates to example \ref{theory:exa1}. The reason why we need to treat the definition and the type of a constant differently is that they take unequal roles in dependent type theory. Sometimes the definition of a constant is crucial to the type safety of an expression, as suggested by example \ref{theory:exa1}, but this is not always the case. Consider the following expression
\[\lambda (f : A \to B) (a : A).f\,a\]
Neither the definition of $f$ nor $a$ is needed to ensure the type correctness of the lambda body ($f\,a$): $f$ could be any function from $A$ to $B$ and $a$ could be any element of $A$, but we know for sure that the type of ($f\,a$) is $B$. 

These two examples illustrate the first aspect of the inequality between the type and the definition in dependent type theory: during the type checking process, the type is indispensable while the definition is only supplementary. This is also the reason why \emph{locking} of definitions is possible during the type checking process.

The other aspect of the inequality between the type and the definition lies in the evaluation process, where only the definition matters whereas the type is discarded altogether. We will describe the evaluation process in more detail when we introduce the semantics of our language.

Principle \ref{theory:p1} forms the basis of our definition mechanism.

Principle \ref{p2} comes as a simple strategy to avoid the pitfall revealed by example \ref{theory:exa2}. During the type checking process, each declaration, including the declarations of bound variables from $\lambda$-abstraction, is checked with the top level context to ensure no name clashing occurs. Using \emph{De Bruijn indices} is another way to avoid this issue. However, having to maintain a relation between the names and indices will complicate our implementation unnecessarily and distract us from the main aim of the project. 

Principle \ref{p3} is less specific by using the phrase `whenever necessary'. Indeed, it is hard to generalize a rule that works in all conditions. The practice of variable renaming is dependent on the syntax of the language and its evaluation strategy. In our implementation, we rename variables in two situations: one is checking the convertibility of two terms and the other is applying the `readback' operation on a term to get its normal form.

Finally, we have a fourth principle in support of our definition mechanism:
\begin{principle} \label{p4}
  Defer computation.
\end{principle}
For the efficiency of our type checking algorithm, we take the following measures to perform as few reductions as possible during the type checking process:
\begin{enumerate}
\item Use \emph{closure} to pass functions around as values.
\item Apply $\beta$-reduction on multi-variable functions in an incremental manner.
\item Build a locking mechanism where definitions of certain constants could be temporarily erased.
\end{enumerate}

Having introduced all these 4 principles, now we are ready to describe in detail the basic form of our language, its syntax, semantics, type checking algorithm and important operations.

\section{Syntax of the Language}\label{theory:sec:syntax}
There are two kinds of syntax regarding the language: (1) The concrete syntax that describes the grammar used in a source file, and (2) the abstract syntax, which is translated from the concrete syntax for clarity and better presentation. What we are going to describe below is the abstract syntax, for the concrete syntax see appendix \ref{apdix:concrete-syntax-basic}. 

Expression in our language is defined as follows:
\begin{definition}[Expression]\label{theory:def:exp}
  \leavevmode \vspace{-\baselineskip}
  \begin{enumerate}[(i)]
    \item $U$ is an expression, which represents a universe of small types. $U$ is an element of itself, i.e., $U \in U$.
    \item A constant/variable is an expression, e.g., $x, y, z$. 
    \item Given two expressions $M, N$, a term of the form
      \[ M\,N \]
      is an expression, which is used to represent function application.
    \item Given two expressions $A, B$ and a variable $x$, a term of the form
      \[ [x : A] B \]
      is an expression, which is used to represent either
      \begin{itemize}
        \item \textbf{$\lambda$-abstraction}: $\lambda[x : A].B$ - a function that given an argument $x$ of type $A$, returns a term $B$ which may dependent on $x$;
      \end{itemize}
      or
      \begin{itemize}
        \item \textbf{Dependent Product}: $\Pi x : A.B$ - the type of functions that given an argument $x$ of type $A$, returns an object of type $B$ which may dependent on $x$. If $B$ does not dependent on $x$($x$ does not occur freely in $B$), then $x$ could be ignored, giving us a term in the form  $\Pi \,\_ : A.B$. This is essentially the same as the type of functions $A \to B$.
      \end{itemize}
    \item Given three expressions $A,B,M$ and a variable $x$, a term of the form
      \[ [x : A = B] M \]
      is an expression, which is used to represent a let clause:
      \begin{itemize}
        \item let $x : A = B$ in $M$.
      \end{itemize}
  \end{enumerate}
\end{definition}

Declaration in our language is defined as follows:
\begin{definition}[Declaration]\label{theory:def:decl}
  \leavevmode \vspace{-\baselineskip}
  \begin{enumerate}[(i)]
  \item Given a name $x$ and an expression $A$, a term of the form
    \[x : A\]
    is a declaration which is used to declare a variable $x$ of type $A$.
  \item Given a name $x$ and two expressions $A,B$, a term of the form
    \[x : A = B\]
    is a declaration which is used to declare a variable $x$ of type $A$ and is defined as $B$.
  \end{enumerate}
\end{definition}

A program of our language consists of a list of declarations. The name of a declaration must not collide with any name of the existing declarations and a variable must be declared before being used. A summary of the syntax could be found in table \ref{theory:tab:syntax}.
\begin{table}[h]
  \centering
  \begin{tabular}{l l l l}
    Exp  & $E$ & ::= & $U \mid x \mid E_1\;E_2 \mid [x : E_1]E_2 \mid [x : E_1 = E_2]E^{*}$ \\
    Decl & $D$ & ::= & $x : E \mid x : E_1 = E_2$ \\
    Prog & $P$ & ::= & $[D]$
  \end{tabular}
  \caption{Syntax of the Language}
  \label{theory:tab:syntax}
\end{table}

The syntax of our language is a subset of Mini-TT\cite{coquand2009simple}. Moreover, we use the same syntax for both dependent product and $\lambda$-abstraction as an effort to maintain simplicity. This practice causes ambiguity only when an expression in the form $[x : A] M$ is viewed in isolation: it can be seen both as a dependent type and a function abstraction. This ambiguity, however, does not cause problem in usage because the meaning of a term could be deduced from its context, our type checking algorithm ensures the consistency of its usage.

\section{Operational Semantics}
Given a well-formed expression of our language, we describe in this section how it is evaluated in the semantics of our language. An expression is evaluated to a \emph{quasi-expression} or \emph{q-expression} given an evaluation context called \emph{environment}. An environment is a stack that keeps track of the variables and their binding q-expressions and can be represented in one of the following forms: 
\begin{definition}[Environment]
  \leavevmode \vspace{-\baselineskip}
  \begin{enumerate}[(i)]
  \item $()$, an empty environment where no variable exists.
  \item $(\rho_1, x = v)$, an environment extended from a smaller environment $\rho_1$ by binding a variable $x$ to a q-expression $v$.
  \item $(\rho_1, x : A = B)$, an environment extended from a smaller environment $\rho_1$ by adding a definition.
  \end{enumerate}
\end{definition}

Intuitively, a \emph{q-expression} is the intermediate form of an expression under evaluation that can be converted to a ``normal'' expression by a ``readback'' procedure which we will describe in section \ref{theory:head-red}. Sometimes we also call q-expressions as \emph{values}.
\begin{definition}[Q-expression]\label{theory:def:q-exp}
  \leavevmode \vspace{-\baselineskip}
  \begin{enumerate}[(i)]
    \item $\mathcal{U}$ is a Q-expression, it represents the result of $U$ under evaluation.
    \item A primitive constant $x$ is a Q-expression, it represents a constant without definition. 
    \item A closure $\langle [x : A] M, \rho \rangle$ is a Q-expression, it represents a function equipped with an evaluation environment.
    \item Given two Q-expressions $k,v$, $k$ is not a closure, a term of the form ($k\,v$) is a Q-expression. It represents an application that cannot be reduced further because either (1) $k$ is not a function($k = \mathcal{U}$), or (2) $k$ is a primitive constant which could be a function but the definition is currently inaccessible (either because of a lack of definition or the definition is locked).
  \end{enumerate}
\end{definition}

The evaluation operation is given by equations of the form $[\![M]\!]\rho = q$, meaning that the expression $M$ evaluates to $q$ under the environment $\rho$.
\begin{table}[h]
  \centering
  \begin{tabular}{l l l}
    $[\![U]\!]\rho$ & = & $\mathcal{U}$ \\
    $[\![x]\!]\rho$ & = & $\rho(x)$ \\
    $[\![M_1 \; M_2]\!]\rho$ & = & $\alpha([\![M_1]\!]\rho, [\![M_2]\!]\rho)$ \\
    $[\![[x : A]\,B]\!]\rho$ & = & $\langle[x : A]\,B, \rho\rangle$ \\
    $[\![[x : A = B]\,M]\!]\rho$ & = & $[\![M]\!](\rho, x : A = B)$ 
  \end{tabular}
  \caption{Semantics of the Language}
  \label{theory:tab:semantics}
\end{table}

Two auxiliary functions are used in the evaluation operation:
\begin{itemize}
\item $\rho(x)$: find the binding q-expression of $x$ from the environment $\rho$.
\item $\alpha(k, v)$: apply function application of $k$ to $v$. 
\end{itemize}

Definitions of these two functions are given in table \ref{theory:tab:lookup}, \ref{theory:tab:app}.
\begin{table}[h]
  \centering
  \begin{tabular}{r l l}
    $()(x)$ & = & $x$ \\
    $(\rho, x = v)(x)$ & = & $v$ \\
    $(\rho, y = v)(x)$ & = & $\rho(x)(y \neq x)$ \\
    $(\rho, x : A = B)(x)$ & = & $[\![B]\!]\rho$ \\
    $(\rho, y : A = B)(x)$ & = & $\rho(x)(y \neq x)$
  \end{tabular}
  \caption{Function - $\rho(x)$}
  \label{theory:tab:lookup}
\end{table}
\begin{table}[h]
  \centering
  \begin{tabular}{r l l}
    $\alpha(\langle [x : A]B, \rho \rangle, v)$ & = & $\llbracket B \rrbracket (\rho, x = v)$  \\
    $\alpha(v1, v2)$ & = & $v1 \; v2$
  \end{tabular}
  \caption{Function - $\alpha(k, v)$}
  \label{theory:tab:app}
\end{table}

It is not hard to see there is a correspondence between the form of an expression and that of an q-expression: $U$ to $\mathcal{U}$; $x$ to $x_1$, the former being a constant which may have a definition whereas the latter being a primitive constant whose definition is inaccessible; $M\,N$ to $k\,v$; and finally, $[x : A] B$ to $\langle[x : A] B, \rho\rangle$. The fact that expressions and q-expressions have similar structure enables us to use the same data type to represent both concepts in our implementation, providing a minor modification to the syntax of expression by adding the form that represents closure. Now a more complete summary of the syntax of our language is given in table \ref{theory:tab:syntax2}. 
\begin{table}[h]
  \centering
  \begin{tabular}{l l l l}
    Exp/Q-Exp  & $E$ & ::= & $U \mid x \mid E_1\;E_2 \mid [x : E_1]E_2 \mid \langle[x : E_1]E_2, \rho\rangle \mid [x : E_1 = E_2]E^{*}$ \\
    Decl & $D$       & ::= & $x : E \mid x : E_1 = E_2$ \\
    Prog & $P$       & ::= & $[D]$
  \end{tabular}
  \caption{Syntax of the Language(2)}
  \label{theory:tab:syntax2}
\end{table}

So we use $U$ for both the type of all small types and $\mathcal{U}$; variables like $x,y,z$ for both constants and primitive constants; $M\,N$ for both function application and the result of its evaluation when $M$ cannot be resolved to a function; $[x : A] B$ for abstraction, $\langle[x : A] B, \rho\rangle$ for closure and $[x : A = B] M$ for a \emph{let} clause.

Mixing expression and q-expression together in one syntax does not cause problem in the implementation as long as we keep in mind which to expect in a certain operation. For example, in the operation ``readback'' where a q-expression is converted back to an expression by eliminating any closures, an error will be raised if it is provided with an abstract or let clause. At the cost of being more careful, we get a more elegant implementation with less code duplication.

Some readers may have noticed that the real difference between expression and q-expression is closure, that is, we use closure to represent the result of evaluation on function abstractions. Closure is an important concept in functional programming and was first conceived by P. J. Landin in his paper \emph{The Mechanical Evaluation of Expressions}\cite{landin1964mechanical}. There, the author described closure as ``$\dots$comprising the $\lambda$-expression and the environment relative to which it was evaluated$\dots$'', which specified the structure of closure that we adhere to in our implementation: a $\lambda$-abstraction and the environment in which it is evaluated, as indicated in table \ref{theory:tab:semantics}. Introducing q-expression as a parallel but distinct concept from expression is motivated by the need to pass functions as values around in the evaluation which is achieved by using closure. Apart from this, using closures brings us two additional features that is important to our definition mechanism: (1) deferred evaluation and (2) partial application.

The meaning of deferred evaluation comes into twofold: evaluation of the body of a $\lambda$-abstraction and the substitution process in a $\beta$-reduction. The first is expressed clearly in the rule about the evaluation of a function abstraction: the body of the abstraction is left intact in the closure; The second is manifested in the function $\alpha(k,v)$, where the application of a closure with an argument results in the evaluation of the function body in a new environment. In the new environment, the head variable ($x$) of the closure is bound with the provided argument. In this case, if the function body ($B$) is another abstraction, then the substitution will not take place and be deferred to a later phase when the evaluation on the head variable is really needed. Being able to defer computation is crucial for our definition mechanism for it allows us to do as few reductions as possible in the type checking process. We will come back to this point whenever relevant in the later part of this paper.

Partial application is the idea that for a function of type $A \to B \to C$, we can provide it with only one argument $a \in A$ to get another function as the result, whose type is $B \to C$. This is also an important feature for our definition mechanism since it allows us to do reductions on multi-variable functions step by step.

The last thing we want to beg for the readers attention before we move on is the second aspect of the inequality between the type and the definition: notice how the type information is altogether discarded in the evaluation process, both when we do reduction on function application and in function $\rho(x)$.

\section{Type Checking Algorithm}\label{theory:sec:check}
The aim of the type checking algorithm is to ensure a program of our language is well-typed. Basically, for a declaration in the form $x : A$, it checks that $A$ is a valid type, namely $A \in U$; for a declaration in the form $x : A = B$, it checks that (1) $A$ is a valid type and (2) $B$ is a well-typed expression and has $A$ as its type. A program is said to be well-typed when each of its declaration is well-typed.

Note that the type checking algorithm does not concern any syntactic error or semantic error related with names, such as duplicated declaration of names or use of undeclared name. Syntactic error is checked by the lexer and parser where a source file is parsed to a syntax tree represented by the concrete syntax mentioned at the beginning of section \ref{theory:sec:syntax}. Semantic error regarding names are checked when the concrete syntax tree is translated to an abstract syntax tree in a procedure we called \emph{translation}. It is the abstract syntax tree to which the type checking algorithm is applied.

There are five forms of judgments.
\begin{table}[h]
  \centering
  \begin{tabular}{l l l}
    checkD   & $\Gamma,s \vdash D \Rightarrow \Gamma'$ & $D$ is a valid declaration and extends $\Gamma$ to $\Gamma'$ \\
    checkI & $\Gamma,s \vdash M \Rightarrow t$ & $M$ is a valid expression and its type is inferred to be $t$ \\
    checkT  & $\Gamma,s \vdash M \Leftarrow t$ & $M$ is a valid expression given type $t$ \\
    checkCI & $\Gamma,s \vdash u \equiv v \Rightarrow t $ & $u, v$ are convertible and their type is inferred to be $t$ \\ 
    checkCT  & $\Gamma,s \vdash u \equiv v \Leftarrow t  $ & $u, v$ are convertible given type $t$
  \end{tabular}
  \caption{Type Checking Judgments}
  \label{theory:tab:judgments}
\end{table}

One thing deserves the readers' special attention: the lower case letters $t,u,v$ appeared in table \ref{theory:tab:judgments} represent q-expressions. This means that (1) the type inferred from a judgment(checkI or checkCI) and the type given as an input to a judgment(checkT, checkCT) must be in the evaluated form; (2) Only the evaluated form of expressions could be checked for convertibility. One can check this statement by the details of the judgments introduced later in the paper.

Each of the judgments is provided with two constructs acting as a premise: a type checking context $\Gamma$ and a lock strategy $s$. A type checking context is a stack that keeps track of the types and definitions of all variables declared so far and is represented in one of the following forms:
\begin{definition}[Type Checking Context]
  \leavevmode \vspace{-\baselineskip}
  \begin{enumerate}[(i)]
  \item $()$ - an empty context where no declaration exists.
  \item $(\Gamma_1, x : A)$ - a context extended from a smaller context $\Gamma_1$ by binding a variable $x$ to its type $A$.
  \item $(\Gamma_1, x : A = B)$ - a context extended from a smaller context $\Gamma_1$ by adding a definition.
  \end{enumerate}
\end{definition}

Given a type checking context, we can query the type of a variable by function $\Gamma(x)$, which means to find the type of $x$ in $\Gamma$. Function $\Gamma(x)$ is defined in table \ref{theory:tab:gamma}.
\begin{table}[h]
  \centering
  \begin{tabular}{r l l}
    $()(x)$ & = & \texttt{error} \\
    $(\Gamma, x : A)(x)$ & = & $A$ \\
    $(\Gamma, y : A)(x)$ & = & $\Gamma(x)(y \neq x)$ \\
    $(\Gamma, x : A = B)(x)$ & = & $A$ \\
    $(\Gamma, y : A = B)(x)$ & = & $\Gamma(x)(y \neq x)$
  \end{tabular}
  \caption{Function - $\Gamma(x)$}
  \label{theory:tab:gamma}
\end{table}

The first case of the function is worth some explanation. It expresses that if we try to get the type of a variable that does not exist in the type checking context, then an error is raised. In our implementation during the \emph{translation} process we mentioned earlier, we make sure that each variable is properly declared with a type and the name of the variable does not clash with the existing ones. By doing so, we ensure that the error condition will never actually happen during the type checking process.

\emph{Lock strategy} is introduced as part of our definition mechanism to enable the locking/unlocking functionality on variables. A variable is \emph{locked} when its definition(provided that it has one) is temporarily erased and \emph{unlocked} if its definition is restored. A locked variable is in effect a primitive that cannot be reduced further. Since environment is the place where variables are mapped to their definitions or values(q-expressions) during evaluation, we can achieve the effect of locking(unlocking) variables by removing(restoring) their definitions from(to) the environment. This suggests a transformation from a type checking context to an environment with the definitions of variables being intentionally erased or restored. This is achieved by a function \emph{getEnv} that given a lock strategy and a type checking context returns an environment, which is denoted by the symbol $\varrho$.

In the current implementation, we have four lock strategies: \emph{LockAll, LockNone, LockList s, UnLockList s}, where \emph{s} is a list of variable names. We denote these four strategies as $\bullet, \circ, \dagger(s), \ddagger(s)$ correspondingly and give the definition of $\varrho$ in table \ref{theory:tab:getEnv}.
\begin{table}[h] 
  \centering
  \begin{tabular}{l l l}
    $\varrho(\bullet, \Gamma)$ & = & () \\
    \\
    $\varrho(\circ, ())$ & = & () \\
    $\varrho(\circ, (\Gamma, x : A))$ & = & $\varrho(\circ, \Gamma)$ \\
    $\varrho(\circ, (\Gamma, x : A = B))$ & = & let $\rho = \varrho(\circ, \Gamma)$ in $(\rho, x : A = B)$ \\
    \\
    $\varrho(\dagger(s), ())$ & = & () \\
    $\varrho(\dagger(s), (\Gamma, x : A))$ & = & $\varrho(\dagger(s), \Gamma)$ \\
    $\varrho(\dagger(s), (\Gamma, x : A = B))$ & = & let $\rho = \varrho(\dagger(s), \Gamma)$ in if $x \in s$ then $\rho$ else $(\rho, x : A = B)$\\
    \\
    $\varrho(\ddagger(s), ())$ & = & () \\
    $\varrho(\ddagger(s), (\Gamma, x : A))$ & = & $\varrho(\ddagger(s), \Gamma)$ \\
    $\varrho(\ddagger(s), (\Gamma, x : A = B))$ & = & let $\rho = \varrho(\ddagger(s), \Gamma)$ in if $x \notin ns$ then $\rho$ else $(\rho, x : A = B)$
  \end{tabular}
  \caption{Function: getEnv}
  \label{theory:tab:getEnv}
\end{table}

Initially, the type checking context is empty. Whenever a declaration is checked to be valid, it is added to the underlying type checking context. We denote this process by $\Gamma,s \vdash D \Rightarrow \Gamma'$ and call it that $D$ is a valid declaration and extends $\Gamma$ to $\Gamma'$. When $D$ has the form $x : A$, $\Gamma' = (\Gamma, x : A)$; otherwise when $D$ has the form $x : A = B$, $\Gamma' = (\Gamma, x : A = B)$. Having introduced the relevant concepts and notations, we show the details of each of the five judgments in sequence.

\subsection{checkD}
\begin{align}
  &\begin{prooftree}
    \hypo{\Gamma,s \vdash A \Leftarrow U}
    \infer1{\Gamma,s \vdash x : A \Rightarrow \Gamma_1}
  \end{prooftree} \\
  \nonumber \\
  &\begin{prooftree}
    \hypo{\Gamma,s \vdash A \Leftarrow U}
    \hypo{\Gamma,s \vdash B \Leftarrow a}
    \infer2{\Gamma,s \vdash x : A = B \Rightarrow \Gamma_1}
  \end{prooftree}\left(\begin{array}{l l l}
                         \rho & = & \varrho(s, \Gamma) \\
                         a & = & \llbracket A \rrbracket \rho 
                       \end{array}\right)
\end{align}
\begin{itemize}
  \item For a declaration of the form $x : A$, we check that $A$ is a valid expression and has type $U$.
  \item For a definition of the form $x : A = B$, we check that
    \begin{enumerate}
    \item $A$ is a valid expression and has type $U$. 
    \item $B$ is a valid expression and has the evaluated form of $A$ as its type. 
    \end{enumerate}
\end{itemize}

\subsection{checkI}
\begin{align}
  &\begin{prooftree}
    \infer0{\Gamma,s \vdash U \Rightarrow U}
  \end{prooftree} \\
  \nonumber \\
  &\begin{prooftree}
    \infer0{\Gamma,s \vdash x \Rightarrow a}
  \end{prooftree}\left(\begin{array}{l l l}
                         \rho & = & \varrho(s, \Gamma) \\
                         A & = & \Gamma(x) \\
                         a & = & \llbracket A \rrbracket \rho
                       \end{array}\right) \\
  \nonumber \\
  &\begin{prooftree}
    \hypo{\Gamma,s \vdash M \Rightarrow \langle [x : A] B, \rho \rangle}
    \hypo{\Gamma,s \vdash N \Leftarrow a}
    \infer2{\Gamma,s \vdash M \; N \Rightarrow b}
  \end{prooftree}\left(\begin{array}{l l l}
                         a & = & \llbracket A \rrbracket \rho \\
                         \rho_0 &= & \varrho(s, \Gamma) \\
                         n & = & \llbracket N \rrbracket \rho_0 \\
                         \rho_1 &= & (\rho, x = n) \\
                         b & = & \llbracket B \rrbracket \rho_1
                       \end{array}\right) \\
  \nonumber \\
  &\begin{prooftree}
    \hypo{\Gamma,s \vdash x : A = B \Rightarrow \Gamma_1}
    \hypo{\Gamma_1,s \vdash M \Rightarrow t}
    \infer2{\Gamma,s \vdash [x : A = B]\,M \Rightarrow t}
  \end{prooftree}
\end{align}

\begin{itemize}
\item The inferred type of $U$ is itself.
\item The inferred type of a variable $x$ is the evaluated form of its type got from the type checking context.
\item For application $M\,N$, we do as follows:
  \begin{enumerate}
  \item Check $M$ is a valid expression and its type can be inferred to be a closure.
  \item Check $N$ is a valid expression given the type of the head variable of the closure.
  \item Get the environment extracted from the current context $\Gamma$, denote it as $\rho_0$.
  \item Get the evaluated form of $N$ from $\rho_0$, denote it as $n$.
  \item Extend $\rho$ to $\rho_1$ by binding $x$ to $n$.
  \item Return the evaluated form of $B$ in $\rho_1$.
  \end{enumerate}
\item For a let clause $[x : A = B] M$, we first check the definition is correct, then infer the type of $M$ under the new context extended by the definition.
\end{itemize}

\subsection{checkT}
\begin{align}
  &\begin{prooftree}
    \infer0{\Gamma,s \vdash U \Leftarrow U}
  \end{prooftree} \\
  \nonumber \\
  &\begin{prooftree}
    \hypo{\Gamma,s \vdash x \Rightarrow v'}
    \hypo{\Gamma,s \vdash v \equiv v' \Rightarrow \_}
    \infer2{\Gamma,s \vdash x \Leftarrow v}
  \end{prooftree} \\
  \nonumber \\
  &\begin{prooftree}
    \hypo{\Gamma,s \vdash M \; N \Rightarrow v'}
    \hypo{\Gamma,s \vdash v' \equiv v \Rightarrow \_}
    \infer2{\Gamma,s \vdash M \; N \Leftarrow v}
  \end{prooftree} \\
  \nonumber \\
  &\begin{prooftree}
    \hypo{\Gamma,s \vdash x : A \Rightarrow \Gamma_1}
    \hypo{\Gamma_1,s \vdash B \Leftarrow U}
    \infer2{\Gamma,s \vdash [x : A] \, B \Leftarrow U}
  \end{prooftree}\label{theory:rule:pi} \\
  \nonumber \\
  &\begin{prooftree}
    \hypo{\Gamma,s \vdash x : A \Rightarrow \Gamma_1}
    \hypo{\Gamma,s \vdash a \equiv a' \Rightarrow \_}
    \hypo{\Gamma_1,s \vdash B \Leftarrow b'}
    \infer3{\Gamma,s \vdash [x : A] \, B \Leftarrow \langle [x' : A'] \, B', \rho \rangle}
  \end{prooftree}\left(\begin{array}{l l l}
                         \rho_0 &= &\varrho(s, \Gamma) \\
                         a &= &\llbracket A \rrbracket \rho_0 \\
                         a' &= &\llbracket A' \rrbracket \rho \\
                         \rho_1 &= &(\rho, x' = x) \\
                         b' &= &\llbracket B' \rrbracket \rho_1
                       \end{array}\right)\label{theory:rule:abs} \\
  \nonumber \\
  &\begin{prooftree}
    \hypo{\Gamma,s \vdash x : A = B \Rightarrow \Gamma_1}
    \hypo{\Gamma_1,s \vdash M \Leftarrow t}
    \infer2{\Gamma,s \vdash [x : A = B]\,M \Leftarrow t}
  \end{prooftree}
\end{align}

\begin{itemize}
\item $U$ is a valid expression given itself as its type.
\item To check that a variable $x$ is valid given $v$ as its type, we do as follows:
  \begin{enumerate}
  \item Check that $x$ is valid and its type can be inferred to be $v'$.
  \item Check that $v$ and $v'$ are convertible.
  \end{enumerate}
\item To check that $M\,N$ is a valid expression given $v$ as its type, we do as follows:
  \begin{enumerate}
  \item Check that $M\,N$ is a valid expression and its type can be inferred to be $v'$.
  \item Check that $v$ and $v'$ are convertible.
  \end{enumerate}
\item To check that $[x : A] B$ is a valid expression given $U$ as its type, we do as follows:
  \begin{enumerate}
  \item Check that the declaration $x : A$ is valid and extends $\Gamma$ to $\Gamma_1$.
  \item In context $\Gamma_1$, check that $B$ is a valid expression given $U$ as its type.
  \end{enumerate}
\item To check that $[x : A] B$ is a valid expression given a closure $\langle [x' : A'] \, B', \rho \rangle$ as its type, we do as follows:
  \begin{enumerate}
  \item Check that the declaration $x : A$ is valid and extend $\Gamma$ to $\Gamma_1$.
  \item Get the environment from $\Gamma$, denote it as $\rho_0$.
  \item Get the evaluated form of $A$ from $\rho_0$, denote it as $a$.
  \item Get the evaluated form of $A'$ from $\rho$, denote it as $a'$.
  \item Check that $a$ and $a'$ are convertible.
  \item Extend $\rho$ to $\rho_1$ by binding $x'$ to $x$.
  \item Get the evaluated form of $B'$ from $\rho_1$, denote it as $b'$.
  \item In context $\Gamma_1$, check that $B$ is a valid expression given $b'$ as its type.
  \end{enumerate}
\item To check that $[x : A = B] M$ is a valid expression given $t$ as its type, we do as follows:
  \begin{enumerate}
  \item Check that the definition $x : A = B$ is valid and extend $\Gamma$ to $\Gamma_1$.
  \item In context $\Gamma_1$, check that $M$ is a valid expression given $t$ as its type. 
  \end{enumerate}
\end{itemize}
Note that the inference rule \ref{theory:rule:pi} and \ref{theory:rule:abs} differentiate between the use of an abstraction $[x:A] B$ as a dependent product or as a function. When used as a dependent product, its type is $U$; otherwise, its type is a dependent product represented by another abstraction.

\subsection{checkCI}
\begin{align}
  &\begin{prooftree}
    \infer0{\Gamma,s \vdash U \equiv U \Rightarrow U} 
  \end{prooftree} \\
  \nonumber \\
  &\begin{prooftree}
    \hypo{x =:= y}
    \hypo{\Gamma,s \vdash x \Rightarrow v}
    \infer2{\Gamma,s \vdash x \equiv y \Rightarrow v} 
  \end{prooftree}\label{theory:checkci:primitive} \\
  \nonumber \\
  &\begin{prooftree}
    \hypo{\Gamma,s \vdash m_1 \equiv m_2 \Rightarrow \langle [x : A] B, \rho \rangle}
    \hypo{\Gamma,s \vdash n_1 \equiv n_2 \Leftarrow a}
    \infer2{\Gamma,s \vdash (m_1 \; n_1) \equiv (m_2 \; n_2) \Rightarrow v} 
  \end{prooftree}\left(\begin{array}{l l l}
                         a &= &\llbracket A \rrbracket \rho \\
                         \rho_1 &= &(\rho, x = n_1) \\
                         v &= &\llbracket B \rrbracket \rho_1 \\
                       \end{array}\right)\label{theory:checkci:app} \\
  \nonumber \\
  &\begin{prooftree}
    \hypo{\Gamma,s \vdash \langle [x : A] \, B, \rho \rangle \equiv \langle [y : A'] \, B', \rho' \rangle \Leftarrow U}
    \infer1{\Gamma,s \vdash \langle [x : A] \, B, \rho \rangle \equiv \langle [y : A'] \, B', \rho' \rangle \Rightarrow U} 
  \end{prooftree} \label{theory:rule:closure}
\end{align}

\begin{itemize}
\item $U$ is only convertible to itself and has type $U$.
\item A variable is only convertible to itself and the type is inferred to be the evaluated form of its type got from the context.
\item To check that two q-expressions $m_1 \; n_1$ and $m_2 \; n_2$ are convertible and infer their type, we do as follows:
  \begin{enumerate}
  \item Check that $m_1$ and $m_2$ are convertible and the type is inferred to be a closure $\langle [x : A] B, \rho \rangle$.
  \item Get the evaluated form of $A$ from the environment $\rho$, denote it as $a$.
  \item Check that $n_1$ and $n_2$ are convertible given $a$ as their type.
  \item Extend $\rho$ to $\rho_1$ by binding variable $x$ to $n_1$. 
  \item Return the evaluated form of $B$ from $\rho_1$ as the inferred type.
  \end{enumerate}
\item To check that two closures are convertible and have $U$ as their type, we check that they are convertible given type $U$. 
\end{itemize}
The last inference rule (\ref{theory:rule:closure}) is only used when two terms as dependent product type ($\Pi x:A.B$) are checked for convertibility. In this case, they have type $U$, not a type of dependent product as in the case when a $\lambda$-abstraction is used to express a function. This reflects a `two-tier' type structure of our system: Only $U$ and dependent products can be used as types.

\subsection{CheckCT}
\begin{align}
  &\begin{prooftree}
    \hypo{\Gamma_1,s \vdash m \equiv n \Leftarrow b}
    \infer1{\Gamma,s \vdash v1 \equiv v2 \Leftarrow \langle [x : A] \, B, \rho \rangle} 
  \end{prooftree}\left(\begin{array}{l l l}
                         a &= & \llbracket A \rrbracket \rho \\
                         y &= & \nu(\Gamma, x) \\
                         \Gamma_1 &= & (\Gamma, y : a) \\
                         \rho_0 &= & \varrho(s, \Gamma) \\
                         m &= & \llbracket  v1 \; y \rrbracket \rho_0 \\
                         n &= & \llbracket v2 \; y \rrbracket \rho_0 \\
                         \rho_1 &= & (\rho, x = y) \\
                         b &= & \llbracket B \rrbracket \rho_1 \\ 
                       \end{array}\right)\label{theory:rule:c1} \\
  \nonumber \\
  &\begin{prooftree}
    \hypo{\Gamma,s \vdash a_1 \equiv a_2 \Leftarrow U}
    \hypo{\Gamma_1,s \vdash b_1 \equiv b_2 \Leftarrow U}
    \infer2{\Gamma,s \vdash \langle [x_1 : A_1] \, B_1, \rho_1 \rangle \equiv \langle [x_2 : A_2] \, B_2, \rho_2 \rangle \Leftarrow U} 
  \end{prooftree}\left(\begin{array}{l l l}
                         a_1 &= & \llbracket A_1 \rrbracket \rho_1 \\ 
                         a_2 &= & \llbracket A_2 \rrbracket \rho_2 \\ 
                         y &= & \nu(\Gamma, x) \\
                         \rho_1' &= & (\rho_1, x_1 = y) \\
                         \rho_2' &= & (\rho_2, x_2 = y) \\
                         b_1 &= & \llbracket B_1 \rrbracket \rho_1' \\
                         b_2 &= & \llbracket B_2 \rrbracket \rho_2' \\
                         \Gamma_1 &= & (\Gamma, y : a_1)
                       \end{array}\right)\label{theory:rule:c2} \\
  \nonumber \\
  &\begin{prooftree}
    \hypo{\Gamma,s \vdash v1 \equiv v2 \Rightarrow t'}
    \hypo{\Gamma,s \vdash t \equiv t' \Rightarrow \_}
    \infer2{\Gamma,s \vdash v1 \equiv v2 \Leftarrow t} 
  \end{prooftree}
\end{align}
A new function $\nu$ is introduced in rule \ref{theory:rule:c1} and \ref{theory:rule:c2}. Given a type checking context $\Gamma$ and a variable $x$, it returns a new variable $y$ that does not exist in $\Gamma$. Generating a new variable comes from the need to do reductions on closures so that the body of a $\lambda$-abstraction could be checked for convertibility. Because the names in a type checking context must be unique, we need to apply a closure with a new variable to respect this rule.

\begin{itemize}
  \item To check that two q-expressions $v1$ and $v2$ are convertible and has type $\langle [x : A] B, \rho \rangle$, we do as follows:
    \begin{enumerate}
    \item Get the evaluated form of $A$ from $\rho$, denote it as $a$.
    \item Get a new variable $y$.
    \item Extend $\Gamma$ to $\Gamma_1$ by binding $y$ to $a$.
    \item Get the environment from $\Gamma$, denote it as $\rho_0$.
    \item Evaluate ($v1 \; y$) in $\rho_0$, denote the result as $m$.
    \item Evaluate ($v2 \; y$) in $\rho_0$, denote the result as $n$.
    \item Extend $\rho$ to $\rho_1$ with $x$ bound to $y$ .
    \item Get the evaluated form of $B$ from $\rho_1$, denote it as $b$.
    \item In context $\Gamma_1$, check that $m$, $n$ are convertible given $b$ as their type.
    \end{enumerate}
  \item To check that two closures are convertible and have type $U$, we do as follows:
    \begin{enumerate}
    \item Get the evaluated form of $A_1$ from $\rho_1$, denote it as $a_1$.
    \item Get the evaluated form of $A_2$ from $\rho_2$, denote it as $a_2$.
    \item Check that $a_1$ and $a_2$ are convertible given type $U$.
    \item Get a new variable $y$.
    \item Extend $\rho_1$ to $\rho_1'$ by binding $x_1$ to $y$.
    \item Extend $\rho_2$ to $\rho_2'$ by binding $x_2$ to $y$.
    \item Get the evaluated form of $B_1$ from $\rho_1'$, denote it as $b_1$.
    \item Get the evaluated form of $B_2$ from $\rho_2'$, denote it as $b_2$.
    \item Extend context $\Gamma$ to $\Gamma_1$ by binding variable $y$ to $a_1$.
    \item In context $\Gamma_1$, check that $b_1$, $b_2$ are convertible given $U$ as their type.
    \end{enumerate}
  \item If the first two rules do not apply, we check $v1$ and $v2$ are convertible and infer their type as $t'$, then we check $t$ and $t'$ are convertible.
\end{itemize}

\section{Definition Mechanism}
Having introduced the semantics and type checking rules of our language, now it is time to give a detailed description of our definition mechanism and summarize its characteristics.

The primary motivation behind our attempt to build a definition mechanism is to study how to do type checking in the presence of definitions in dependent type theory. In any typed language, one basic problem a type checker should be able to solve is given an expression $E$ and a type $A$, decide whether $E$ is of type $A$. Usually this involves getting the type of $E$, say $T$, by means of computation regarding the composition of $E$ and decide whether $T$ and $A$ are equal. This is the convertibility problem we introduced in section \ref{chapter:intro:issue}. Difficulty arises in dependent type theory because (1) a type may contain \textbf{any} expression which could entail large amount of computation, and (2) definition opens up the possibility to denote arbitrary complex computation by a single constant. For the type checker of a dependently typed language to be efficient and thus practical, during the type checking process, it should not exceed too much the amount of reductions that are ``just enough'' to establish the equivalence between terms. The problem is, there is no standard way to calculate the minimum number of reductions needed, it dependents on the semantics of the language being used, namely the language designer's perception about how computation should be performed. For example, consider again the two formulae $(1 + 1)^{10}$ and $2^{(5+5)}$. To check the convertibility of these two terms, if we adopt the common arithmetic definition about integer multiplication and exponentiation, and determine that in the evaluation process, an expression should be reduced to the normal form(i.e., no more function application could be applied), then a type checker loyal to our conception of computation will reduce both terms to 1024 to conclude that they are convertible. However, if we change our mind and see exponentiation as a primitive with no definition, then the same type checker with our updated conception about computation would only reduce both terms to $2^{10}$.

For readers who have seen the semantics and type checking rules of our language, our reiteration of the example and idea from section \ref{chapter:intro:aim} above is to show them that, the incorporating a locking functionality on constants is the most basic characteristic of our definition mechanism, and this mechanism is not a modularized feature with a clear boundary with the rest of the system, but built into the semantics and type checking rules of the language. This can be best illustrated by connecting some facts about the evaluation and type checking process: a constant without definition will not appear in the environment(see table \ref{theory:tab:getEnv}); a constant without a binding value or definition in the environment will be evaluated to a primitive(in the same form of itself)(see the first rule of table \ref{theory:tab:lookup}); a primitive is only convertible to itself(see rule \ref{theory:checkci:primitive}). With this observation, it is not hard to visualize how $(1+1)^{10}$ and $2^{(5+5)}$ could be checked convertible in our system by reducing both terms to $2^{10}$ according to the semantics of application and applying rule \ref{theory:checkci:app} about convertibility twice, provided that the set of natural numbers, addition operation, exponentiation operation have been properly defined and the definition of exponentiation is locked.

Our definition mechanism is an attempt to tackle the problem of convertibility checking by setting limit on computations based on constants. That is, a constant acts as a unit on which computations could be locked or charged. More advanced computation control technique with finer granularity is desired, as can be shown by the following example which is only a minor variation of the example above. Consider these two formulae $2 * 2^9$ and $2^{10}$, in this case, locking the definition of exponentiation will not work. One solution for this problem is to recognize and utilize the property about exponentiation: $2^m * 2^n = 2^{(m+n)}$; the other way is to reduce $2^{10}$ to $2 * 2^9$ by unlocking the definition of exponentiation only once. The former suggests establishing properties about data types and operations which is adopted by Haskell and proof-assistant systems like Agda; the latter indicates a dynamic changing of evaluation strategy. Although in this work, we didn't go any further towards either or the two direction, we do study and implement an operation called ``head-reduction'' that could limit computation on small steps each time. An introduction to this operation is given in section \ref{theory:head-red}.

\subsection{Find Minimum Set of Unlocked Constants}
(further description goes here...)

\subsection{Head Reduction}\label{theory:head-red}
\emph{Head-reduction} could be seen as another way to achieve locking strategy: instead of locking on variables, it locks expressions. The intuition about head reduction is that it allows expressions to be evaluated step by step instead of being fully evaluated at one time. More precisely, head reduction defines a binary relation $R$ on the set of all expressions $E$: for $a, b \in E$, if $\Gamma \vdash R(a, b)$ holds, then we say $a$ is \emph{head-reduced} to $b$. When incorporated into a locking mechanism, head reduction has the advantage that terms not fully evaluated could be checked for convertibility, thus giving the prospect that equality between two terms could be established with less computation. We give the definition of head reduction by a set of inference rules that describe the binary relation it defines on the expressions of our language. 

\begin{align}
  &\begin{prooftree}
    \infer0{\Gamma \vdash R(U, U)} 
  \end{prooftree} \\
  \nonumber \\
  &\begin{prooftree}
    \hypo{\Gamma \vdash R(A, A')}
    \hypo{\Gamma_1 \vdash R(M, M')}
    \infer2{\Gamma \vdash R([x : A] M, [x : A'] M')} 
  \end{prooftree}\left(\begin{array}{l l l}
                         va &= & \llbracket A \rrbracket () \\
                         \Gamma_1 &= & (\Gamma, x : va)
                       \end{array}\right) \\
  \nonumber \\
  &\begin{prooftree}
    \hypo{\Gamma_1 \vdash R(M, M')}
    \infer1{\Gamma \vdash R([x : A = B] M, [x : A = B] M')} 
  \end{prooftree}\left(\begin{array}{l l l}
                         \Gamma_1 &= & (\Gamma, x : A = B)
                       \end{array}\right) \\
  \nonumber \\
  &\begin{prooftree}
    \infer0{\Gamma \vdash R(e, e')}
  \end{prooftree}\left(\begin{array}{l l l}
                         ns &= & \texttt{namesCont}(\Gamma) \\
                         ve &= & \texttt{headRedV}(\Gamma, e) \\
                         e' &= & \texttt{readBack}(ns, ve)
                       \end{array}\right)
\end{align}

The rules above states that: For $U$, it head reduces to itself; For abstraction $[x : A] M$, if $A$ head reduces to $A'$ and $M$ head reduces to $M'$ when $\Gamma$ is extended to $\Gamma_1$, then it head reduces to $[x : A'] M'$; For a let clause $[x : A = B] M$, if $M$ head reduces to $M'$ in the extended context, then it head reduces to $[x : A = B] M'$; For expressions in the other form, the head reduction operation relies on two more primitive functions: \texttt{headRedV} and \texttt{readBack}, whereas \texttt{headRedV} relies further on the function \texttt{defVar}. 
\begin{itemize}
\item $\texttt{headRedV} :: \texttt{Cont} \to \texttt{Exp} \to \texttt{QE}$: Evaluates an expression into a q-expression by a `small' step under a given context. \texttt{Cont} is the type of context, \texttt{Exp} the type of expression and \texttt{QE} the type of q-expression. 
\item $\texttt{readBack} :: \texttt{[String]} \to \texttt{QE} \to \texttt{Exp}$: Transforms a q-expression back into an expression by eliminating all potential closures. A list of names taken from the underlying context is given as the first argument to avoid the name clashing problems. 
\item $\texttt{defVar} :: \texttt{String} \to \texttt{Cont} \to \texttt{Exp}$: Get the definition of a constant from the context.
\end{itemize}
This means that an expression $e$ is first evaluated by a `small' step, then read back to an expression $e'$ ($e'$ could be the same as $e$).

The definitions of \texttt{headRedV, readBack} and \texttt{defVar} are given in table \ref{tab:func-primitive}. Notice how the empty environment `$()$' is used in function \texttt{headRedV} to limit the steps of reductions performed.

\begin{table}[h]
  \centering
  \begin{tabular}{l l p{8cm}}
    $\texttt{headRedV}(\Gamma, x)$ & = & let $M_x = \texttt{defVar}(x, \Gamma)$ in $\llbracket M_x \rrbracket ()$ \\
    $\texttt{headRedV}(\Gamma, (e1 \; e2))$ & = & let $v1 = \texttt{headRedV}(\Gamma, e1)$, $v2 = \llbracket e2 \rrbracket ()$ \newline in $\texttt{appVal}(v1, v2)$ \\
    \\
    $\texttt{readBack}(\_, U)$ & = & $U$ \\
    $\texttt{readBack}(\_, x)$ & = & $x$ \\
    $\texttt{readBack}(ns, (v1 \; v2))$ & = & let $e_1 = \texttt{readBack}(ns, v1)$, $e_2 = \texttt{readBack}(ns, v2)$ \newline in ($e_1 \; e_2$) \\
    $\texttt{readBack}(ns, \langle [\varepsilon : A] B \rangle \rho)$ & = & let $A' = \texttt{readBack}(ns, \llbracket A \rrbracket \rho)$, \newline $B' = \texttt{readBack}(ns, \llbracket B \rrbracket \rho)$ \newline in $[\varepsilon : A'] B'$ \\
    $\texttt{readBack}(ns, \langle [x : A] B \rangle \rho)$ & = &  let $y = \texttt{freshVar}(x, ns)$, \newline $va = \llbracket A \rrbracket \rho$, \newline $\rho_1 = (\rho, x = y)$, \newline $vb = \llbracket B \rrbracket \rho_1$, \newline $A' = \texttt{readBack}(ns, va)$, \newline $B' = \texttt{readBack}((y : ns), vb)$, \newline in $[y : A'] B'$ \\
    \\
    $\texttt{defVar}(x, ())$ & = & $x$ \\
    $\texttt{defVar}(x, (\Gamma, x' : \_))$ & = & if $x == x'$ then $x$ else $\texttt{defVar}(x, \Gamma)$ \\
    $\texttt{defVar}(x, (\Gamma, x' : \_ = M))$ & = & if $x == x'$ then $M$ else $\texttt{defVar}(x, \Gamma)$
  \end{tabular}
  \caption{Functions: headRedV, readBack, defVar}
  \label{tab:func-primitive}
\end{table}

As an example of head reduction, we present below in the listing \ref{lst:head-loop} the result of applying head reduction to a constant named `\texttt{loop}' which we take from a file written in our language (see appendix \ref{apdix:loop}). The file represents a variation of Hurkens paradox \cite{hurkens1995simplification} and is used as a test case for our program. There, evaluating the constant `\texttt{loop}' in an environment with all constants unlocked will cause the program to loop forever. However, we can use head reduction to show the results of the first few steps of evaluation.

\begin{lstlisting}[caption=Results of Head Reduction on the Constant Loop,label=lst:head-loop, basicstyle=\ttfamily]

  step 1:
  lem2 lem3

  step 2:
  lem3 B lem1 ([ p : Pow U ] lem3 ([ z : U ] p (delta z)))

  step 3:
  lem1 C ([ x : U ] lem1 (delta x))
    ([ p : Pow U ] lem3 ([ z : U ] p (delta z)))

  step 4:
  lem3 ([ z : U ] B (delta z)) ([ x : U ] lem1 (delta x))
    ([ p : Pow U ] lem3 ([ z : U ] p
      (delta (delta z))))

  step 5:
  lem1 (delta C) ([ x : U ] lem1 (delta (delta x)))
    ([ p : Pow U ] lem3 ([ z : U ] p
      (delta (delta z))))

  step 6:
  lem3 ([ z : U ] B (delta (delta z)))
    ([ x : U ] lem1 (delta (delta x)))
      ([ p : Pow U ] lem3 ([ z : U ] p
        (delta (delta (delta z)))))

  step 7:
  lem1 (delta (delta C)) ([ x : U ] lem1
    (delta (delta (delta x))))
      ([ p : Pow U ] lem3 ([ z : U ]
        p (delta (delta (delta z)))))
\end{lstlisting}