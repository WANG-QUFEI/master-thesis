% CREATED BY DAVID FRISK, 2016
\chapter{Introduction}
\section{Background}
Dependent type theory originated in the work of AUTOMATH\cite{de1994survey} initiated by N.G. de Bruijn in the 1960s. Since then it has lent much of its power to the proof-assistant systems like Coq\cite{huet1997coq}, Agda\cite{norell2008dependently} and contributed much to their success. Essentially, dependent types are types that depend on values of other types. As a simple example, consider the type that represents vectors of length $n$ comprising of elements of type $A$, which can be expressed as a dependent type ($\texttt{vec}\; A\; n$). Readers may easily recall that in imperative languages such as C/C++ or Java, there are array types which depend on the type of their elements, but not types that depend on values of other types. More formally, suppose we have defined a function which to an arbitrary object $x$ of type $A$ assigns a type $B(x)$, then the Cartesian product $\Pi_{x:A}B(x)$ is a type, namely the type of functions which take an arbitrary object $x$ of type $A$ into an object of type $B(x)$.

The advantage of having a strongly typed system built into a language lies in the fact that well typed programs exclude a large portion of run-time errors than those without or with only a weak type system. Just as the famous saying puts it “well-type programs cannot ‘go wrong’” [16]. It is in this sense that we say languages with dependent types are guaranteed with the highest level of correctness and precision, which makes them a natural option for building proof assistant systems.

The downside of dependent type systems, however, lies in the difficulties of implementation. One major difficulty is checking the convertibility of terms, that is, given two terms $A$ and $B$, decide whether they are equal or not. Checking the convertibility of terms that represent types is a frequently performed task by the type checker of any typed language, the way it is conducted affects directly the performance of the language. In a simple typed language, convertibility checking is done by simply checking the syntactic identity of the symbols of the types. For example, in Java, a primitive type \emph{int} equals only to itself, nothing more. This is because types in Java are not computable \footnote{Technically speaking, the type of an object in Java can be retrieved by the Java \emph{reflection} mechanism and presented in the form of another object, thus subject to computation. Here, we stress on the fact that a type as a term is not computable on the syntactic level, e.g. being passed as an argument to a function.}: there's no way for other terms in Java to be reduced to the term \emph{int}. In a dependently typed language, however, the problem is more complex since a type could contain any expression as its component and deciding the convertibility of types in this case entails evaluation on expressions, which could incur much more computation.

\section{Aim}\label{chapter:intro:structure}
The aim of this project is to study how to present definitions in dependent type theory. More specifically, we study how to do type checking in dependent type theory with the presence of definitions. A definition in dependent type theory is a declaration of the form $x : A = B$, meaning that $x$ is a constant of type $A$, defined as $B$, where $A,B$ are expressions of the language. The subtlety about definition in a dependent type theory is that when checking the convertibility of terms, sometimes the definition of a constant is indispensable while other times erasing the definition helps to improve efficiency by cutting off unnecessary computation. Suppose we have a definition of the exponentiation operation on natural numbers as
\begin{align*}
  \texttt{expo} &: \texttt{Nat} \to \texttt{Nat} \to \texttt{Nat} \\
  \texttt{expo} &\;\; \_\;\; 0 = 1 \\
  \texttt{expo} &\;\; n \;\; m = n * (\texttt{expo} \;\; n \;\; (m - 1))
\end{align*}
where \texttt{Nat} represents the type of natural number and $*,-$ represent the multiplication and subtraction operations on natural numbers respectively. When checking the convertibility of two terms $\texttt{expo}\;2\;10$ and 1024, the definition of \texttt{expo} is necessary to reduce the first to 1024. However, if the terms are changed to $\texttt{expo}\;(1 + 1)\;10$ and $\texttt{expo}\;2\;(5+5)$, instead of using the definition of \texttt{expo} to reduce both terms to 1024, we could keep \texttt{expo} \textbf{locked} and only reduce both sides to the term $\texttt{expo}\;2\;10$. By showing that they can be reduced to a common term (having the same symbolic representation), we can prove their equality with much less computation.

The first part of this project consists of the specification of a dependently typed language which features a definition mechanism where constants could be locked/unlocked manually during the type checking process. The first part contains the main theoretical results of this project and a thorough exposition of the definition mechanism is given in section \ref{theory:sec:definition}. As an application of the definition mechanism, we built in the second part a module system based on the concept ``segment'' borrowed from the work AUTOMATH\cite{balsters1994lambda}. The adaptation to the concept of namespace introduced by the module system could be seen as an evidence for the scalability of our definition mechanism.

\section{Organization of This Paper}
This paper is organized as follows: chapter \ref{chapter:theory} starts with three examples to illustrate the common pitfalls one should avoid in the implementation of a dependent type theory. Based on the examples, we put forward two principles used as guidance in our own implementation. We then present in detail the syntax, semantics and type checking algorithm of this language and conclude this chapter with a thorough description of the definition mechanism. Chapter \ref{chapter:extension} starts with an introduction to the concept of segment and the relevant terminologies. This is followed by a detailed description on the syntax, semantics and type checking algorithm of the extended language. Chapter \ref{chapter:results} presents as the result a REPL (read-evaluate-print-loop) program with commands to load and type check a source file of our language and experiment with the definition mechanism. Chapter \ref{chapter:conclusion} concludes the paper with a short review of this project.

\section{Limitations of the Project}
\begin{enumerate}
\item \textbf{Expressiveness:} The expressiveness of the language is intentionally restrained as an attempt to keep the language simple to focus on the study of a definition mechanism. As a consequence there is no language facility to create new data types.
\item \textbf{Metatheory:} Due to the limit of time, a study on the properties of our language as a type theory and logic system will not be included. This could be seen as one of the directions of the future work.
\end{enumerate}
