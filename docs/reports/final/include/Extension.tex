% CREATED BY DAVID FRISK, 2016
\chapter{Extension}\label{chapter:extension}
We describe in this chapter an extension to our language: a module system based on the concept of `segment' borrowed from the work of AUTOMATH. For an introduction to the usage of segment in AUTOMATH, we refer the readers to H. Balsters's work\cite{balsters1994lambda}. Here, we only illustrate its influence on our design of a module system by giving an example as follows. Note that in the following discussions, we use the words `segment' and `module' interchangeably.
\begin{example} \label{exm:seg}
  The idea of \emph{segment} is to have a new form of declaration \[x = ds\; \texttt{Seg}\]
  where $x$ is the name of the segment and $ds$ a list of declarations. The word `Seg' is designed as a language keyword and a segment can also be seen as a module with parameters. For example,
  \[ s = [ A : *,\; id : A \to A = [x : A]\; x ]\; \texttt{Seg} \] 
  is a module which contains a declaration and a definition. The declaration (\( A : * \footnote{`*' represents U, the type of small types}\)) is a parameter of the module and the definition $id$ is the identity function defined in this module. Suppose we have another declaration (\( A0 : * \)), then the expression \( (s \, [A0]).id \) has $A0 \to A0$ as its type and closure $([x : A]x)(A = A0)$ as its value. 
\end{example}

From this example we can see that a segment in our language is an abbreviation for a collection of declarations. We give the definition of segment by listing the relevant concepts and grammatical rules as follows.
\begin{definition}[Segment]
  \leavevmode \vspace{-\baselineskip}
  \begin{itemize}
  \item A segment can be declared as $x = \texttt{Seg}\;ds$ where $x$ is the \emph{name} of the segment and $ds$ consisting of a list of declarations is the \emph{content} of the segment.
  \item An \emph{empty segment} is a segment whose content is an empty list. Declaration of an empty segment is allowed grammatically but of no practical use.
  \item Segments can be nested, i.e., a segment can be declared within another segment. The segment which contains other segments is called the \emph{parent} and the segment(s) contained in a parent is(are) called the \emph{child(children)}. We use the symbol $\to$ to denote the parent-child relation such that $a \to b$ iff $a$ is the parent of $b$.
  \item For the variables that are declared in the segment $s$, $s$ is called their \emph{declaring segment}. 
  \item There is a \emph{default segment} that is implicitly inhabited at the top-level and is denoted as \emph{s-root}.
  \item The children segments and their children are called \emph{descendants} to the parent segment; To the descendants, the parent segment and its parent up to \emph{s-root} are called the \emph{ancestors}.
  \item The \emph{path} of a segment is the list of names that relate \emph{s-root} to it under the relation $\to$. For example, if a segment is declared with name ``a'' in the default segment, its path is $[a]$; if another segment is declared with name ``b'' in segment \emph{a}, its path is $[a,b]$. The path of \emph{s-root} is the empty list.
  \item The \emph{namespace} of a variable or segment is the string formed by joining the names in the path of its declaring/parent segment by the full stop character. For example, for a variable declared in a segment whose path is $[a,b,c]$, its namespace is ``a.b.c''. The namespace of the variables or segments in \emph{s-root} is the empty string.
  \item The \emph{qualified name} of a variable is the string formed by joining its namespace and name by a full stop character. For example, the qualified name of a variable $x$ in the default segment is ``.x''; the qualified name of a variable $x$ with namespace ``a.b.c'' is ``a.b.c.x''. We also call the usual, non-qualified name the \emph{short name}. In the following discussion whenever we use the word ``name'' we mean the \emph{short name} unless otherwise specified. We also use the notation with `q' in the subscript of a lower case letter to denote a variable in its qualified name, e.g., $x_q, y_q$.
  \item The \emph{relative path} of a segment $s$ to an ancestor $a$ is the list of names that relate $a$ to $s$ under the relation $\to$. For example, if $b$ is a child of $a$ and $c$ is child of $b$, the relative path of $c$ to $a$ is $[b,c]$.  
  \item The \emph{relative namespace} of a variable or segment to an ancestor $a$ is the string formed by joining the names in the relative path of its declaring/parent segment to $a$ by the full stop character. For example, if $s1$ is a segment where $x$ is declared as a variable and $s2$ is declared as a segment; In $s2$, $y$ is declared as a variable, then the relative namespace of $x$ to $s1$ is the empty string and the relative namespace of $y$ to $s1$ is ``s2''.
  \item A \emph{parameter} of a segment is a declaration of the form $x:A$ in this segment.
  \item A segment can be \emph{instantiated} by giving a list of expressions. If the segment has no parameter, the list must be empty; otherwise the expressions in the list must have the same type as the parameters of the segment correspondingly. The result is a new segment with the variables of the parameters in the old segment bound to the expressions provided as their definitions. For example, for a segment $s$ with parameters $[x : A, y : B, z : C]$, it can be instantiated by a term of the form $s\,[M_1, M_2, M_3]$ where $M_1, M_2, M_3$ are expressions with types $A, B, C$ respectively.
  \item A segment can have no parameter. In that case, it can only be instantiated by an empty list and resulting in a new segment that is a replicate of itself.
  \item A segment can be declared by the instantiation of another segment, i.e., we have declarations of the form $s1 = s2\,[M_1,\dots,M_n]$ where $s1$ is an instantiation of $s2$.
  \item Objects (variables and segments) in a segment $s$ or its descendants can be accessed by the dot operation $(.)$: on the left of the operator is the relative namespace of the object to the segment $s$ whereas on the right is the name of the object. If the relative namespace is the empty string, which means the object is declared in $s$, it is referred directly by its name. Both of the relative namespace and the name are used without quotes, i.e., if the relative namespace is ``a.b.c'' and the name is ``x'', variable $x$ in segment $c$ could be accessed from the parent segment of $a$ by term $a.b.c.x$. This form of access is called the \emph{direct access}. 
  \item The other form of access is \emph{access by instantiation}, where the segment referred by the name at the end of a relative path is instantiated before the object is accessed. It has the form $s_1.\,\dots\,.s_n\,[M_1,\dots,M_n]\,.\,x$, where $[s_1,\dots,s_n]$ is the relative path of $s_n$ to the parent of $s_1$, the segment where the access happens, and $[M_1,\dots,M_n]$ are the expressions used to instantiate $s_n$.
  \item Expressions in a segment $s$ can only refer to the entities from $s$ or its descendants that have already been declared. This means that terms of the form ($s1\,[M_1,\dots,M_{i}]\,.\,\dots\,.s_n\,[N_1,\dots,N_j]\,.\,x$) is not necessary because instantiation on the ancestors has no effect on the descendants. We take a step further and consider terms of this form illegal in our language. We call this the rule of \textbf{Reference Confinement}.
  \item Name of a declaration cannot collide with names already existed in the same segment. There is no restriction on names from different segments.  
  \end{itemize}
\end{definition}

\section{Syntax of the Extended Language}
We introduce below the abstract syntax of the extended language, for the concrete syntax see appendix \ref{apdix:concrete-syntax-extend}. Expression in the extended language is defined as follows:
\begin{definition}[Expression]
  \leavevmode \vspace{-\baselineskip}
  \begin{enumerate}[(i)]
  \item Terms of forms $U$, $[x:A]M$, $D\,M$ that are defined in \ref{theory:def:exp} are expressions in the extended language with the same meaning.
  \item Given a non-empty list of names $[s_1,\dots,s_n]$, a name $x$ and an empty-possible list of tuples $[(M_1, x_1),\dots,(M_i,x_i)]$ where $M_j$ represents an expression and $x_j$ a name, a new form of term
    \[ s_1.\,\dots\,.s_n\,[(M_1,x_1),\dots,(M_i,x_i)]\,.\,x \]
    is an expression and belongs to the subset $\mathcal{K}$. When the list of tuples is not empty, it represents an \emph{access by instantiation} to the variable $x$ in the segment $s_n$, whose relative path to the current segment is $[s_1,\dots,s_n]$. In this case, $x_1$ to $x_m$ represent the names of the parameters of $s_n$ that should be bound to expressions $M_1$ to $M_n$ correspondingly; otherwise it represents a \emph{direct access} to the variable $x$ in the segment $s_n$. Pairing each expression with the name of its corresponding parameter facilitates the evaluation and type checking process on expressions.
  \end{enumerate}
\end{definition}

Declaration in the extended language is defined as follows.
\begin{definition}[Declaration]
  \leavevmode \vspace{-\baselineskip}
  \begin{enumerate}[(i)]
  \item Terms of the form $x : A$, $x : A = B$ that are defined in \ref{theory:def:decl} are still declarations in the extended language and have the same meaning.
  \item Given a name $s$ and an empty-possible list of declarations $ds$, a term of the form
    \[ s = \texttt{Seg}\;ds \]
    is a declaration which is used to declare a segment $s$ consisting of the list of declarations $ds$. \texttt{Seg} in this case is a reserved word of the language.
  \item Given a name $s$, a non-empty list of names $[s_1,\dots,s_n]$ and an empty-possible list of tuples $[(M_1, x_1),\dots,(M_i,x_i)]$, a term of the form
    \[ s = s_1.\,\dots\,.s_n\,[(M_1,x_1),\dots,(M_i,x_i)] \]
    is a declaration which is used to declare a segment $s$ by the instantiation of another segment $s_n$. The relative path of $s_n$ to the current segment is $[s_1,\dots,s_n]$.
  \end{enumerate}
\end{definition}

A program of the extended language consists of a list of declarations which belong to the default segment \emph{s-root}. Each segment is uniquely identified by its path and each variable is uniquely identified by its qualified name. A summary of the syntax of the extended language could be found int table \ref{extension:tab:syntax}.
\begin{table}[h]
  \centering
  \begin{tabular}{l l l}
    $A,M$ & ::= & $U \mid K \mid [x : A]M \mid D\,M $ \\
    $K$ & ::= & $x \mid s_1.\,\dots\,.s_n\,[(M_1,x_1),\dots,(M_i,x_i)]\,.\,x \mid K\,M $ \\
    $D$ & ::= & $x : A = M$ \\
    $S$ & ::= & $s = \texttt{Seg}\;[Decl] \mid s = s_1.\,\dots\,.s_n\,[(M_1,x_1),\dots,(M_i,x_i)]$ \\
    $Decl$ & ::= & $x : A \mid D \mid S$ \\
    $P$ & ::= & $[Decl]$
  \end{tabular}
  \caption{Syntax of the Extended Language}
  \label{extension:tab:syntax}
\end{table}

\section{Operational Semantics}
In the evaluation operation, each segment has a representation of an environment. The fact that segments can be nested suggests a tree-like structure for the environment.
\begin{definition}[Environment]
  An environment $\rho$ is a stack with an attribute $p$ which represents the path of its corresponding segment and can be expressed in one of the following forms.
  \begin{itemize}
  \item $()$: $\rho$ is an empty environment.
  \item $(\rho_1, x=v)$: $\rho$ is an environment extended from $\rho_1$ by binding a variable $x$ to a q-expression $v$, $\rho$ shares the same path with $\rho_1$.
  \item $(\rho_1, D)$: $\rho$ is an environment extended from $\rho_1$ by a definition, $\rho$ shares the same path with $\rho_1$.
  \item $(\rho_1, s=\rho')$: $\rho$ is an environment extended from $\rho_1$ by a sub-environment $\rho'$ which represents the child segment with name $s$, $\rho$ shares the same path with $\rho_1$. If we denote the path of $\rho$ as $\rho_p$, the path of $\rho'$ is $\rho'_p = \rho_p + [s]$.
  \end{itemize}
\end{definition}

The definition of q-expression in the extended language is the same as \ref{theory:def:q-exp} and we still use the notation $M_\rho = q$ to express that expression $M$ is evaluated to $q$ in environment $\rho$. Semantics of the extended language is given in table \ref{extension:tab:semantics}.
\begin{table}[h]
  \centering
  \begin{tabular}{l l p{8cm}}
    $U_\rho$ & = & $U$ \\
    $(K\,N)_\rho$ & = & $app(K_{\rho}, N_{\rho})$ \\
    $([x : A]B)_\rho$ & = & $\langle [x : A]B,\rho \rangle$ \\
    $(D\,M)_\rho$ & = & $M_{(\rho, D)}$ \\
    $x_\rho$ & = & $\rho(x)$ \\
    $(s_1.\,\dots\,.s_n\,[(M_1,x_1),\dots,(M_i,x_i)]\,.\,x)_\rho$ & = & let $\rho_1 = \iota_{\rho}([s_1,\dots,s_n], [(M_1,x_1)\dots,(M_i,x_i)])$ \newline in $\rho_1(x)$
  \end{tabular}
  \caption{Semantics of the Extended Language}
  \label{extension:tab:semantics}
\end{table}

The evaluation rules for expressions in forms of $U, (K\,N), [x:A]M, D\,M$ remain the same as that in table \ref{theory:tab:semantics}. To evaluate variables from the current segment and variables accessed by instantiation, two auxiliary functions are needed.
\begin{itemize}
\item $\rho(x)$: evaluate variable $x$ in environment $\rho$.\footnote{we overload this function with a new definition.}
\item $\iota_\rho(rp, ens)$: get the environment corresponding to the segment which is the result of instantiation on another segment by a list of tuples $ens$. The relative path of the segment being instantiated  to $\rho$\footnote{more precisely, it should be the segment represented by $\rho$. To avoid verbosity, we adopt the practice to use the word ``environment ($\rho$)'' instead of the phrase ``the segment represented by the environment ($\rho$)'' whenever there is no ambiguity. We use the same practice when we talk about type checking context in the following sections.} is $rp$.
\end{itemize}
Function $\rho(x)$ relies on function $\mathcal{Q}(\rho_p,x)$: given the path of $\rho$, it returns the qualified name of variable $x$ in $\rho$. The definition of $\rho(x)$ is given in table \ref{extension:tab:lookup}. 
\begin{table}[h]
  \centering
  \begin{tabular}{r l l}
    $()(x_q)$ & = & $x_q$ \\
    $()(x)$ & = & $\mathcal{Q}(()_p, x)$ \\
    $(\rho, x' = v)(x)$ & = & if $x == x'$ then $v$ else $\rho(x)$ \\
    $(\rho, x' : A = B)(x)$ & = & if $x==x'$ then $B_\rho$ else $\rho(x)$ \\
    $(\rho, x' = \rho')(x)$ & = & $\rho(x)$
  \end{tabular}
  \caption{Function - $\rho(x)$}
  \label{extension:tab:lookup}
\end{table}

Function $\iota$ relies further on function \emph{findSegEnv} and two operations \emph{mfst, msnd}.
\begin{itemize}
\item \emph{findSegEnv}$(rp, \rho)$: find the environment $\rho_1$ whose relative path to $\rho$ is $rp$. We use the notation $\rho_1 = \rightsquigarrow_{rp}\rho$ to express this function for brevity.
\item \emph{mfst}: extracts the first element from each tuple in a list, so for a list of tuples of the form $[(a_1,b_1),\dots,(a_n,b_n)]$, the result is  $[a_1,\dots,a_n]$.
\item \emph{msnd}: extracts the second element from each tuple in a list, so for a list of tuples of the form $[(a_1,b_1),\dots,(a_n,b_n)]$, the result is $[b_1,\dots,b_n]$.
\end{itemize}

The definition of $\iota$ is given in table \ref{extension:tab:segEnv}, where $es_\rho$ represents evaluation on a list of expressions $es$ in the environment $\rho$; $(\rho_1, \sum_i(x_i=v_i))$ represents the environment extended from $\rho_1$ by binding variables $x_i$ from a list to q-expressions $v_i$ from a list.
\begin{table}[h]
  \centering
  \begin{tabular}{l l p{6cm}}
    $\iota_\rho(rp, ens)$ & = & let $\rho_1 = \rightsquigarrow_{rp}\rho$, $es = \textit{mfst}(ens)$, $ns = \textit{msnd}(ens)$, $qs = es_\rho$ \newline in $(\rho_1, \sum_i(x_i=v_i)), x_i \in ns, v_i \in qs$
  \end{tabular}
  \caption{Function - $\iota$}
  \label{extension:tab:segEnv}
\end{table}

\section{Type Checking Algorithm}\label{extension:sec:type-check}
During the type checking process, each segment has a representation of a type checking context which is constructed in a tree-like structure.
\begin{definition}[Type Checking Context]
  A type checking context $\Gamma$ is a stack with an attribute $p$ which represents the path of its corresponding segment and can be expressed in one of the following forms.
  \begin{itemize}
  \item $()$: $\Gamma$ is an empty context.
  \item $(\Gamma_1, x : A)$: $\Gamma$ is a context extended from $\Gamma_1$ by a declaration, $\Gamma$ shares the same path with $\Gamma_1$.
  \item $(\Gamma_1, D)$: $\Gamma$ is a context extended from $\Gamma_1$ by a definition, $\Gamma$ shares the same path with $\Gamma_1$.
  \item $(\Gamma_1, s=\Gamma')$: $\Gamma$ is a context extended from $\Gamma_1$ by a sub-context $\Gamma'$ which represents the child segment with name $s$, $\Gamma$ shares the same path with $\Gamma_1$. If we denote the path of $\Gamma$ as $\Gamma_p$, the path of $\Gamma'$ is $\Gamma'_p = \Gamma_p + [s]$.
  \end{itemize}
\end{definition}
Given a type checking context $\Gamma$ and a lock strategy $s$, we can get the evaluated form of the type of a variable $x$ by function \emph{getType} which is denoted as $\Gamma(s,x)$. Function $\Gamma(s,x)$ will always succeed because only variables from $\Gamma$ or its descendants are queried for types. This is guaranteed by (1) the rule of \emph{Reference Confinement} which regulates that variables outside the segment cannot be referred inside and (2) a \emph{translation} procedure which converts a concrete syntax tree to an abstract syntax tree where proper declaration and usage of variables are checked. If $x$ appears in the form of short name, it is declared in $\Gamma$; otherwise $x$ is declared in a descendant of $\Gamma$. To find the type of a variable in a descendant segment, we introduce a function \emph{locateSeg} which given a context $\Gamma$ and a variable $x$ in its qualified name, finds the relative path of the declaring segment of $x$ to $\Gamma$. The relative path $rp$ returned from this function can be used to get the context of the descendant by function $findSegCtx$. We use the notation $\Gamma_1 = \rightsquigarrow_{rp}\Gamma$ to express that $\Gamma_1$ is the descendant of $\Gamma$ whose relative path is $rp$. For a qualified name $x_q$, the function \emph{sname}$(x_q)$ returns the short name $x$. The definition of $\Gamma(s,x)$ is given in table \ref{extension:tab:getType}.
\begin{table}[h]
  \centering
  \begin{tabular}{r l p{10cm}}
    $\Gamma(s,x_q)$ & = & let $rp = \emph{locateSeg}(\Gamma, x_q)$, $\Gamma_1 = \rightsquigarrow_{rp}\Gamma$ \newline $x = \emph{sname}(x_q)$ in $\Gamma_1(s,x)$ \\
    $(\Gamma', x' : A)(s, x)$ & = & if $x' == x$ then  $A_{\varrho(s, \Gamma')}$ else $\Gamma'(s, x)$ \\
    $(\Gamma', x' : A = B)(s, x)$ & = & if $x' == x$ then  $A_{\varrho(s, \Gamma')}$ else $\Gamma'(s, x)$ \\
    $(\Gamma', x' = \Gamma_1)(s,x)$ & = & $\Gamma'(s,x)$
  \end{tabular}
  \caption{Function - getType}
  \label{extension:tab:getType}
\end{table}

For the type checking algorithm, the lock strategy in the extended language have the same meaning as that of the basic language except that variables to be locked now are specified by their qualified names. There are four forms of judgments:
\begin{table}[h]
  \centering
  \begin{tabular}{l l p{10cm}}
    checkD & $\Gamma \vdash_s d \Rightarrow \Gamma'$ & $d$ is a valid declaration and extends $\Gamma$ to $\Gamma'$. \\
    checkT & $\Gamma \vdash_s M \Leftarrow t$ & $M$ is a valid expression given type $t$. \\
    checkI & $\Gamma \vdash_s K \Rightarrow t$ & $K$ is a valid expression and its type is inferred to be $t$. \\ 
    checkInst & $\Gamma,\Gamma' \vdash_s (M,x) \Rightarrow \Gamma_1$ & $M$ has the same type as the variable $x$ in $\Gamma'$. $\Gamma_1$ is the segment resulting from the instantiation on the parameter $x$ of segment $\Gamma'$ by $M$.
  \end{tabular}
  \caption{Forms of Judgment}
  \label{extension:tab:judgments}
\end{table}

\subsection{checkD}
\begin{align}
  &\begin{prooftree}\label{extension:checkD:decl}
    \hypo{\Gamma \vdash_s A \Leftarrow U}
    \infer1{\Gamma \vdash_s x : A \Rightarrow (\Gamma, x:A)}
  \end{prooftree} \\
  \nonumber \\
  &\begin{prooftree}\label{extension:checkD:def}
    \hypo{\Gamma \vdash_s A \Leftarrow U}
    \hypo{\Gamma \vdash_s B \Leftarrow A_{\varrho(s,\Gamma)}}
    \infer2{\Gamma \vdash_s x : A = B \Rightarrow (\Gamma, x:A=B)}
  \end{prooftree}\\
  \nonumber \\
  &\begin{prooftree}\label{extension:checkD:seg}
    \hypo{\Gamma_0 \vdash_s d_1 \Rightarrow \Gamma_1}
    \ellipsis{}{\Gamma_{n-1},s \vdash_s d_n \Rightarrow \Gamma_n}
    \infer1{\Gamma \vdash_s s = \texttt{Seg}\,[d_1,\dots,d_n] \Rightarrow (\Gamma, s=\Gamma_n)}
  \end{prooftree}\left(\begin{array}{l}
                         \Gamma_0 = \epsilon(\Gamma_p + [s])
                       \end{array}\right) \\
  \nonumber \\
  &\begin{prooftree}\label{extension:checkD:instSeg}
    \hypo{\Gamma,\Gamma_0 \vdash_s (M_1,x_1) \Rightarrow \Gamma_1}
    \ellipsis{}{\Gamma, \Gamma_{i-1} \vdash_s (M_i,x_i) \Rightarrow \Gamma_i}
    \infer1{\Gamma \vdash_s s = s_1.\,\dots\,.s_n\,[(M_1,x_1),\dots,(M_i,x_i)] \Rightarrow (\Gamma, s=\Gamma_i)}
  \end{prooftree}\left(\begin{array}{l}
                         rp = [s_1,\dots\,s_n] \\
                         \Gamma_0 = \rightsquigarrow_{rp}\Gamma
                       \end{array}\right)
\end{align}
$\epsilon(\Gamma_p + [s])$ in rule \ref{extension:checkD:seg} is a function that given a path $\Gamma_p + [s]$ returns an empty context with that path.

\subsection{checkInst}
\begin{align}
  \begin{prooftree}
     \hypo{\Gamma \vdash_s M \Leftarrow \Gamma'(s,x)}
     \infer1{\Gamma,\Gamma' \vdash_s (M,x) \Rightarrow \mathcal{U}(\Gamma', x, M_{\varrho(x,\Gamma)})}
  \end{prooftree}
\end{align}
$\mathcal{U}(\Gamma', x, q)$ is a function which turns the parameter $x$ of segment $\Gamma'$ to a definition, i.e., suppose $x$ is declared as $x:A$ in $\Gamma'$, this function returns a new context having the same content as $\Gamma'$ except that $x$ has a definition $x:A=q$.

\subsection{checkT}\label{extension:subsec:checkT}
\begin{align}
  &\begin{prooftree}\label{extension:checkT:u}
    \infer0{\Gamma \vdash_s U \Leftarrow U}
  \end{prooftree} \\
  \nonumber \\
  &\begin{prooftree}\label{extension:checkT:x}
    \hypo{\Gamma(s,x) \sim_{\tau(\Gamma)} t}
    \infer1{\Gamma \vdash_s x \Leftarrow t}
  \end{prooftree}\\
  \nonumber \\
  &\begin{prooftree}\label{extension:checkT:app}
    \hypo{\Gamma \vdash_s K \, N \Rightarrow t'}
    \hypo{t' \sim_{\tau(\Gamma)} t}
    \infer2{\Gamma \vdash_s K \, N \Leftarrow t}
  \end{prooftree} \\
  \nonumber \\
  &\begin{prooftree}\label{extension:checkT:abs}
    \hypo{\Gamma \vdash_s A \Leftarrow U}
    \hypo{(\Gamma, x:A) \vdash_s B \Leftarrow U}
    \infer2{\Gamma \vdash_s [x : A]B \Leftarrow U}
  \end{prooftree}\\
  \nonumber \\
  &\begin{prooftree}\label{extension:checkT:clos}
    \hypo{\Gamma \vdash_s A \Leftarrow U}
    \hypo{A_{\varrho(s,\Gamma)} \sim_{\tau(\Gamma)} A'_{\rho'}}
    \hypo{(\Gamma, x : A) \vdash_s B \Leftarrow B'_{(\rho', x'=x_q)}}
    \infer3{\Gamma \vdash_s [x : A] \, B \Leftarrow \langle [x' : A'] B',\rho' \rangle}
  \end{prooftree}\left(\begin{array}{l}
                         x_q = \mathcal{Q}(\Gamma_p, x)
                       \end{array}\right)\\
  \nonumber \\
  &\begin{prooftree}\label{extension:checkT:let}
    \hypo{\Gamma \vdash_s A \Leftarrow U}
    \hypo{\Gamma \vdash_s B \Leftarrow A_{\varrho(s,\Gamma)}}
    \hypo{(\Gamma, x:A=B) \vdash_s M \Leftarrow t}
    \infer3{\Gamma \vdash_s [x : A = B]\,M \Leftarrow t}
  \end{prooftree} \\
  \nonumber \\
  &\begin{prooftree}\label{extension:checkT:x_seg}
    \hypo{\Gamma,\Gamma_0 \vdash_s (M_1,x_1) \Rightarrow \Gamma_1}
    \ellipsis{}{\Gamma, \Gamma_{i-1} \vdash_s (M_i,x_i) \Rightarrow \Gamma_i}
    \hypo{\Gamma_i(s,x) \sim_{\tau(\Gamma)} t}
    \infer2{\Gamma \vdash_s s_1.\,\dots\,.s_n\,[(M_1,x_1),\dots,(M_i,x_i)].x \Leftarrow t}
  \end{prooftree}\left(\begin{array}{l}
                         rp = [s_1,\dots\,s_n] \\
                         \Gamma_0 = \rightsquigarrow_{rp}\Gamma
                       \end{array}\right) 
\end{align}
$\mathcal{Q}(\Gamma_p, x)$ in rule \ref{extension:checkT:clos} is a function that given the path of $\Gamma$ returns the qualified name of variable $x$ from $\Gamma$.

\subsection{checkI}
\begin{align}
  &\begin{prooftree}\label{extension:checkI:x}
    \infer0{\Gamma \vdash_s x \Rightarrow \Gamma(s,x)}
  \end{prooftree} \\
  \nonumber \\
  &\begin{prooftree}\label{extension:checkI:app}
    \hypo{\Gamma \vdash_s K \Rightarrow \langle [x : A] B,\rho \rangle}
    \hypo{\Gamma \vdash_s N \Leftarrow A_\rho}
    \infer2{\Gamma \vdash_s K\,N \Rightarrow B_{(\rho, x = n)}}
  \end{prooftree}\left(\begin{array}{l}
                         n = N_{\varrho(s, \Gamma)}
                       \end{array}\right) \\
  \nonumber \\
  &\begin{prooftree}\label{extension:checkI:seg_x}
    \hypo{\Gamma,\Gamma_0 \vdash_s (M_1,x_1) \Rightarrow \Gamma_1}
    \ellipsis{}{\Gamma,\Gamma_{i-1} \vdash_s (M_{i},x_{i}) \Rightarrow \Gamma_i}
    \infer1{\Gamma \vdash_s s_1.\,\dots\,.s_n\,[(M_1,x_1),\dots,(M_i,x_i)].x \Rightarrow \Gamma_i(s,x)}
  \end{prooftree}\left(\begin{array}{l}
                         rp = [s_1,\dots,s_n] \\
                         \Gamma_0 = \rightsquigarrow_{rp}\Gamma
                       \end{array}\right)
\end{align}

% \subsection{checkCI}
% \begin{align}
%   &\begin{prooftree}\label{extension:checkCI:u}
%     \infer0{\Gamma \vdash_s U \equiv U \Rightarrow U} 
%   \end{prooftree} \\
%   \nonumber \\
%   &\begin{prooftree}\label{extension:checkCI:x}
%     \hypo{x =:= y}
%     \hypo{\Gamma \vdash_s x \Rightarrow v}
%     \infer2{\Gamma \vdash_s x \equiv y \Rightarrow v} 
%   \end{prooftree}\\
%   \nonumber \\
%   &\begin{prooftree}\label{extension:checkCI:app}
%     \hypo{\Gamma \vdash_s m_1 \equiv m_2 \Rightarrow \langle [x : A] B, \rho \rangle}
%     \hypo{\Gamma \vdash_s n_1 \equiv n_2 \Leftarrow a}
%     \infer2{\Gamma \vdash_s (m_1 \; n_1) \equiv (m_2 \; n_2) \Rightarrow v} 
%   \end{prooftree}\left(\begin{array}{l l l}
%                          a &= &\llbracket A \rrbracket \rho \\
%                          \rho_1 &= &\sum(\rho, x, n_1) \\
%                          v &= &\llbracket B \rrbracket \rho_1 \\
%                        \end{array}\right)\\
%   \nonumber \\
%   &\begin{prooftree}\label{extension:checkCI:clos}
%     \hypo{\Gamma \vdash_s \langle [x : A] \, B, \rho \rangle \equiv \langle [y : A'] \, B', \rho' \rangle \Leftarrow U}
%     \infer1{\Gamma \vdash_s \langle [x : A] \, B, \rho \rangle \equiv \langle [y : A'] \, B', \rho' \rangle \Rightarrow U} 
%   \end{prooftree}
% \end{align}
% \begin{itemize}
% \item \ref{extension:checkCI:u}, \ref{extension:checkCI:x}, \ref{extension:checkCI:app}, \ref{extension:checkCI:clos} are the same with \ref{theory:checkCI:u}, \ref{theory:checkCI:x}, \ref{theory:checkCI:app}, \ref{theory:checkCI:clos} respectively. One minor difference is that in \ref{extension:checkCI:app}, we use the notation $\sum(\rho, x, n1)$ to express the environment extended from $\rho$ by binding $x$ to the q-expression $n1$.
% \end{itemize}

% \subsection{CheckCT}
% \begin{align}
%   &\begin{prooftree}\label{extension:checkCT:v}
%     \hypo{\Gamma_1,s \vdash_s m \equiv n \Leftarrow b}
%     \infer1{\Gamma \vdash_s v1 \equiv v2 \Leftarrow \langle [x : A] \, B, \rho \rangle} 
%   \end{prooftree}\left(\begin{array}{l l l}
%                          ns & = & \tau(\Gamma) \\
%                          y  & = & \nu(ns, x) \\
%                          \rho_0 & = & \varrho(s, \Gamma) \\
%                          m &= & \llbracket  v1 \; y \rrbracket \rho_0 \\
%                          n &= & \llbracket v2 \; y \rrbracket \rho_0 \\
%                          y' & = & \sigma(\Gamma_p, y) \\
%                          \rho' & = & \sum(\rho, x, y') \\
%                          a &= & \llbracket A \rrbracket \rho \\
%                          \Gamma_1 & = & \sum(\Gamma, y, a) \\
%                          b & = & B\rho'
%                        \end{array}\right)\\
%   \nonumber \\
%   &\begin{prooftree}\label{extension:checkCT:clos}
%     \hypo{\Gamma \vdash_s a_1 \equiv a_2 \Leftarrow U}
%     \hypo{\Gamma_1,s \vdash_s b_1 \equiv b_2 \Leftarrow U}
%     \infer2{\Gamma \vdash_s \langle [x_1 : A_1] B_1, \rho_1 \rangle \equiv \langle [x_2 : A_2] B_2, \rho_2 \rangle \Leftarrow U} 
%   \end{prooftree}\left(\begin{array}{l l l}
%                          a_1 &= & \llbracket A_1 \rrbracket \rho_1 \\ 
%                          a_2 &= & \llbracket A_2 \rrbracket \rho_2 \\ 
%                          ns & = & \tau(\Gamma) \\
%                          y &= & \nu(ns, x_1) \\
%                          y' & = & \sigma(\Gamma_p, y) \\
%                          \rho_1' &= & (\rho_1, x_1 = y') \\
%                          \rho_2' &= & (\rho_2, x_2 = y') \\
%                          b_1 &= & \llbracket B_1 \rrbracket \rho_1' \\
%                          b_2 &= & \llbracket B_2 \rrbracket \rho_2' \\
%                          \Gamma_1 &= & (\Gamma, y : a_1)
%                        \end{array}\right)\\
%   \nonumber \\
%   &\begin{prooftree}\label{extension:checkCT:t}
%     \hypo{\Gamma \vdash_s v1 \equiv v2 \Rightarrow t'}
%     \hypo{\Gamma \vdash_s t \equiv t' \Rightarrow \_}
%     \infer2{\Gamma \vdash_s v1 \equiv v2 \Leftarrow t} 
%   \end{prooftree}
% \end{align}
% \begin{itemize}
%   \item Despite its similarity with \ref{theory:checkCT:v}, we describe \ref{extension:checkCT:v} in detail as follows.
%     \begin{enumerate}
%     \item Get the list of names declared in $\Gamma$ and use it to generate a new variable $y$.
%     \item Get the environment from $\Gamma$, denote it as $\rho_0$.
%     \item Evaluate ($v1 \; y$) in $\rho_0$, denote the result as $m$.
%     \item Evaluate ($v2 \; y$) in $\rho_0$, denote the result as $n$.
%     \item Get the qualified name of $y$ from path $\Gamma_p$, denote it as $y'$.
%     \item Extend $\rho$ to $\rho_1$ with $x$ bound to $y'$ .
%     \item Get the evaluated form of $A$ from $\rho$, denote it as $a$.
%     \item Extend $\Gamma$ to $\Gamma_1$ by binding $y$ to $a$.
%     \item Get the evaluated form of $B$ from $\rho_1$, denote it as $b$.
%     \item In context $\Gamma_1$, check that $m$, $n$ are convertible given $b$ as their type.
%     \end{enumerate}
%   \item Despite its similarity with \ref{theory:checkCT:clos}, we describe \ref{extension:checkCT:clos} in detail as follows.
%     \begin{enumerate}
%     \item Get the evaluated form of $A_1$ from $\rho_1$, denote it as $a_1$.
%     \item Get the evaluated form of $A_2$ from $\rho_2$, denote it as $a_2$.
%     \item Check that $a_1$ and $a_2$ are convertible given type $U$.
%     \item Get the list of names declared in $\Gamma$ and use it to generate a new variable $y$.
%     \item Get the qualified name of $y$ from path $\Gamma_p$, denote it as $y'$.
%     \item Extend $\rho_1$ to $\rho_1'$ by binding $x_1$ to $y'$.
%     \item Extend $\rho_2$ to $\rho_2'$ by binding $x_2$ to $y'$.
%     \item Get the evaluated form of $B_1$ from $\rho_1'$, denote it as $b_1$.
%     \item Get the evaluated form of $B_2$ from $\rho_2'$, denote it as $b_2$.
%     \item Extend context $\Gamma$ to $\Gamma_1$ by binding variable $y$ to $a_1$.
%     \item In context $\Gamma_1$, check that $b_1$, $b_2$ are convertible given $U$ as their type.
%     \end{enumerate}
%   \item \ref{extension:checkCT:t} is the same with \ref{theory:checkCT:t}.
% \end{itemize}

% The main difference between \ref{extension:checkCT:v} and \ref{theory:checkCT:v}, \ref{extension:checkCT:clos} and \ref{theory:checkCT:clos} is that we use a qualified name to initiate a primitive to express the concept of namespace that variables are identified uniquely by their qualified name.

\section{Linear Head Reduction}
Function \emph{linear head reduction} in the extended language has the same definition as that in table \ref{theory:tab:head-red}, so does the function \emph{readBack}. The definition of \emph{headRedV}, however, is different because of the introduction of segment.
\begin{table}[h]
  \centering
  \begin{tabular}{p{5cm} l p{8cm}}
    $\delta^*(\Gamma, x)$ & = & $\mathcal{V}(\Gamma, x)$ \\
    $\delta^*(\Gamma, s_1.\,\dots\,.s_n$ \newline $[(M_1,x_1),\dots,(M_i,x_i)]\,.\,x)$ & = & let $rp = [s_1,\dots,s_n]$, $\rho = \varrho([], \Gamma)$, \newline $\rho_1 = \iota_\rho(rp, [(M_1,x_1),\dots,(M_i,x_i)])$, \newline in $\mathcal{V}(\rho_1, x)$ \\
    $\delta^*(\Gamma, K\,N)$ & = & let $k = \delta^*(\Gamma, K)$, $n = N_{()}$ in $app(k,n)$ \\
  \end{tabular}
  \caption{Function - HeadRedV in Extended Language}
  \label{extension:tab:headRedV}
\end{table}

Function \emph{getVal} ($\mathcal{V}$) in the table \ref{extension:tab:headRedV} is overloaded to express: (1) $\mathcal{V}(\Gamma, x)$, the function to get the least evaluated form of variable $x$ from context $\Gamma$; and (2) $\mathcal{V}(\rho, x)$, the function to get the least evaluated form of variable $x$ from environment $\rho$. Different with that of table \ref{theory:tab:getVal}, when $\mathcal{V}$ is used to get the least evaluated form of a variable $x$ form a context $\Gamma$, variable $x$ could be in the form of its qualified name $x_q$. In this case, the function needs to locate the sub-context where $x$ is declared in a similar way as that of table \ref{extension:tab:getType}. We give the definition of \emph{getVal} in both cases in table \ref{extension:tab:getVal}.
\begin{table}[h]
  \centering
  \begin{tabular}{l l l}
    $\mathcal{V}(\Gamma, x_q)$ & = &  let $rp = \emph{locateseg}(\Gamma, x_q)$, $\Gamma' = \rightsquigarrow_{rp}\Gamma$, $x=\emph{sname}(x_q)$ in $\mathcal{V}(\Gamma',x)$ \\
    $\mathcal{V}((), x)$ & = & $x$ \\
    $\mathcal{V}(\Gamma', s=\Gamma_1)$ & = & $\mathcal{V}(\Gamma', x)$ \\
    $\mathcal{V}((\Gamma', x' : A), x)$ & = & if $x' == x$ then $x$ else $\mathcal{V}(\Gamma', x)$ \\
    $\mathcal{V}((\Gamma', x' : A = B), x)$ & = & if $x' == x$ then $B_{()}$ else $\mathcal{V}(\Gamma', x)$ \\
    \\
    \hline
    \\
    $\mathcal{V}((), x)$ & = & $x$ \\
    $\mathcal{V}(\rho', s=\rho_1)$ & = & $\mathcal{V}(\rho', x)$ \\
    $\mathcal{V}((\rho', x' : A = B), x)$ & = & if $x' == x$ then $B_{()}$ else $\mathcal{V}(\rho', x)$ 
  \end{tabular}
  \caption{Function - getVal}
  \label{extension:tab:getVal}
\end{table}

An example of the function head reduction in the extended language is given in appendix \ref{apdix:hred:extend}, which is the result of applying head reduction repeatedly to the constant ``loop'' and the results defined in appendix \ref{apdix:paradox:seg}. It shows the same result as appendix \ref{apdix:hred} but performed with the involvement of segment.