% CREATED BY DAVID FRISK, 2016
\chapter{Appendix}
\section{Concrete Syntax for the Basic Language} \label{apdix:concrete-syntax-basic}
\begin{verbatim}
position token Id (char - ["\\\n\t[]():;. "])+;

entrypoints Context, CExp, CDecl;

Ctx. Context ::= [CDecl];

CU.      CExp2 ::= "*";
CVar.    CExp2 ::= Id;
CApp.    CExp1 ::= CExp1 CExp2;
CArr.    CExp  ::= CExp1 "->" CExp;
CPi.     CExp  ::= "[" Id ":" CExp "]" CExp;
CWhere.  CExp  ::= "[" Id ":" CExp "=" CExp "]" CExp ;

CDec.    CDecl ::= Id ":" CExp;
CDef.    CDecl ::= Id ":" CExp "=" CExp;


terminator CDecl ";";

coercions CExp 3;

comment "--";

comment "{-" "-}";
\end{verbatim}

\section{Concrete Syntax for the Extended Language} \label{apdix:concrete-syntax-extend}
\begin{verbatim}
position token Id ((char - ["\\\n\t[]():;,.0123456789 "]) 
  (char - ["\\\n\t[]():;,. "])*);

entrypoints Context, Exp, Decl;

Ctx. Context ::= [Decl] ;

U.        Exp2 ::= "*" ;
Var.      Exp2 ::= Ref ;
SegVar.   Exp2 ::= Ref "[" [Exp] "]" "." Id ;
App.      Exp1 ::= Exp1 Exp2 ;
Arr.      Exp  ::= Exp1 "->" Exp ;
Abs.      Exp  ::= "[" Id ":" Exp "]" Exp ;
Let.      Exp  ::= "[" Id ":" Exp "=" Exp "]" Exp ;

Dec.      Decl ::= Id ":" Exp ;
Def.      Decl ::= Id ":" Exp "=" Exp ;
Seg.      Decl ::= Id "=" "seg" "{" [Decl] "}" ;
SegInst.  Decl ::= Id "=" Ref "[" [Exp] "]" ; 

Ri.       Ref  ::= Id ;
Rn.       Ref  ::= Ref "." Id ;

separator Decl ";" ;

separator Exp "," ;

coercions Exp 3;

layout "seg";

layout toplevel;

comment "--";

comment "{-" "-}";
\end{verbatim}

\section{Test Case} \label{apdix:loop}
\begin{verbatim}
Pow : * -> * =
  [X : *] X -> * ;

T : * -> * =
  [X : *] Pow (Pow X) ;

⊥ : * = [X : *] X ;

funT : [X : *] [Y : *] (X -> Y) -> T X -> T Y =
  [X : *][Y : *][f : X -> Y][t : T X][g : Y -> *] t ([x : X] g (f x)) ;

¬ : * -> * =
  [X : *] X -> ⊥ ;

U : * = [X : *] (T X -> X) -> T X ;

tau : T U -> U =
  [t : T U][X : *][f : T X -> X] [p : Pow X] t ([x : U] p (f (x X f))) ;

sigma : U -> T U =
  [z : U] z U tau ;

delta : U -> U = [z : U] tau (sigma z) ;

Q : T U =
  [p : U -> *][z : U] sigma z p -> p z ;

B : Pow U =
  [z : U] ¬ ([p : Pow U] sigma z p -> p (delta z)) ;

C : U = tau Q ;

lem1 : Q B
  = [z : U] [k : sigma z B] [l : [p : Pow U] sigma z p -> p (delta z)] l B k ([p : Pow U] l ([z1 : U] p (delta z1))) ;

A : * = [p : Pow U] Q p -> p C ;

lem2 : ¬ A
  = [h : A] h B lem1 ([p : Pow U] h ([z : U] p (delta z))) ;

lem3 : A
  = [p : Pow U] [h : Q p] h C ([x : U] h (delta x)) ;

loop : ⊥
  = lem2 lem3 ;

delta2 : U -> U = [z : U] delta (delta z) ;
\end{verbatim}
